---
layout: post
title: 观察者模式
date: 2017-11-11 11:11:11.000000000 +09:00
---

#### 观察者模式也叫发布-订阅模式，即Publish/Subscirbe,

#### 定义：
> 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，这个主题对象再状态发生改变时，会通知所有观察真对象，使他们能够自动更新自己。




其实这个模式其实是最常用的。

我想起了上段时间做的一个物联网项目，用的是MQTT协议，也是基于发布订阅模式的。当时对观察者模式不了解，所以弄了好久才明白。废话不多说。开始吧。

![](http://upload-images.jianshu.io/upload_images/4236553-c7aa73e4c66395ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


我们看一看上面的UML类图，先看接口Subject，译为‘主题’，在观察者模式中，担任通知者的角色，即通知接口。我们在看看Oberver接口，译为 ‘观察者’，就是被观察者。下面分别是实现他们的子类。我们看ConcresteSubject这个类，在他的属性中，有Observers属性，是个集合，即Observer集合，存储过个被观察者的对象。并且有两个方法，一个是增加被观察者方法，一个是删除观察者方法，一个是通知所有观察者方法。

我们再看ConcreaeObserver类，是一个被观察者的具体实现类，其中有一个update方法，其功能就是在通知者调用notify方法的时候，其实执行的就是他的update方法。

总体就是：通知者和观察者是聚合的关系，也即是‘弱’的拥有关系。每个实现Subject类的子类中都有Observer接口的饮用，用于存储被观察者，方便管理。

从发布订阅这个词来解说的话，就是：被观察者订阅了通知者的主题，当通知者发布主题时，就调用notify方法告诉所有订阅的被观察者。

观察者模式的应用场景：

当一个对象的改变需要改变其他对象的时候。补充一下，而且他不知道具体有多少对象待改变时，应该考虑用观察者模式。

当一个抽象模式有两个方面，其中一方面依赖于另一方面，这时用观察者模式可以将这两者封装在独立的对象中使他们各自独立地改变和复用。

###### 总的来讲:

> 观察者模式所做的工作其实就是在解除耦合，让耦合的双方都依赖于抽象，二不是依赖于具体，从而使得各自的变化都不会影响另一边的变化。
