---
layout: post
title: 深入理解-Tomcat(十)-总结
date: 2017-11-29 11:11:11.000000000 +09:00
---
![](http://upload-images.jianshu.io/upload_images/4236553-c48bf4c6abcafd48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


## 前言

这篇文章是我们深入理解 Tomcat 的第十篇文章,也是总结文章, 学习就是这样,先是理论,再是实践,最后是总结, 楼主习惯了在每次学习之后总结, 让从脑海中过的知识能够再扎实一点.

我们的第一篇文章 `<< 深入理解 Tomcat（一）源码环境搭建和 How Tomcat works 源码>> `中介绍了楼主下载的源码和 git 地址, 方便大家去 clone 源码,不然怎么来依据理论去剖析源码实现呢? 楼主认为, 任何一门技术都要借助文档和源码一起去理解(可能是楼主比较菜).  而楼主也放了2个源码,一个是使用 maven 改过的 tomcat 7 源码,一个是名著 <<How Tomcat Works>> 的实例源码, 方便我们更深入的理解 tomcat.

源码环境搭建好了,楼主从网上,从早上... 额,不, 从各个地方看文章, 想了解 tomcat 的结构设计和文档, 当然也搭配楼主从图书馆借来的 `<<How Tomcat Works>>` 书, 最终写了一篇 `<<深入理解 Tomcat (二) 从宏观上理解 Tomcat 组件及架构>>`, 我们讲了我们准备如何学习, 以及什么是 Tomcat ,  什么是 Servlet, tomcat 源码目录的解释, tomcat 整体框架的层次结构和架构图, 分析每个组件, 包括 Connector, Container,  Component, 也从接口和类的角度(UML 类图)看架构. 这让我们对 tomcat 整体也有了一个大致的了解, 为我们接下来的分析源码做了铺垫.

我们在大致了解了 tomcat 的整体架构和设计后, 我们想了解一个最简单的 web 服务器是如何实现的, 我们写了一篇`<< 深入理解 Tomcat（三）Tomcat 底层实现原理>>`, 参照` <<How Tomcat Works>> `源码实现了一个简单的阻塞式的 Web 服务器, 虽然现在最新的 Tomcat 9 已经将阻塞 socket 去除了,全部使用 NIO 和 JNI 以提高速度, 但他仍是我们学习的一个很好的例子.

在了解原理之后, 我们开始循序渐进, 我们的第一个研究的就是著名的 Tomcat 的类加载机制, 于是我们写了一篇 `<< 深入理解 Tomcat（四）Tomcat 类加载器之为何违背双亲委派模型>>,` 先从 java 的类加载器开始分析, 分析双亲委任模型的原理, 以及类加载机制的发展及变化,  最后讲 Tomcat 的类加载机制的设计, 讲 Tomcat 为何破坏双亲委派模型. 也讲了 Tomcat 中每个类加载器的功能. 从理论上了解了 Tomcat 类加载器的设计. 为我们从源码层面理解做了铺垫.

在了解了 Tomcat 的类加载器理论后, 我们第一次开始 debug tomcat 的源码, 写了一篇`<<深入理解 Tomcat（五）源码剖析Tomcat 启动过程----类加载过程>>`, 从 BootStrap 开始, 我们一步步分析 Tomcat 是如何加载类,加载 jar 包, 是如何将公用的 jar 包使用 common 类加载器, 而私有的 jar 包及 web 应用使用
 WebAppClassLoader 的. 并且知道了 WebAppClassLoader的加载时间和另外几个的时间不一致. 从源码层面知道了 Tomcat 的类加载设计和机制.

我们继续深入 tomcat, 开始按照我们在第二篇文章中的计划去阅读源码, 我们写了 `<< 深入理解 Tomcat（六）源码剖析Tomcat 启动过程----生命周期和容器组件>>`,  深入源码去了解 tomcat 是如何设计容器,容器是如何初始化的, 又是如何交给 JMX 去管理对象的. tomcat 的众多容器又是如何通过观察者模式来管理他们的生命周期的. 

在了解了 tomcat 的生命周期组件和容器初始化过程后, 我们决定从整体上看看 tomcat 是如何启动的又是如何关闭的, 我们写了 `<<深入理解 Tomcat（七）源码剖析 Tomcat 完整启动过程>>`并且也见到 tomcat 传说中的钩子. tomcat 的关闭很有趣, 靠着启动一个 socket 去发送SHUTDOWN命令.

之后我们决定去深入另一个很重要的组件----连接器, 在 `<<深入理解 Tomcat（八）源码剖析之连接器>>`中, 我们深入源码,  理解了连接器 Connector 的构造过程, 连接器是如何初始化的, 又是如何启动, 启动之后如何监听 Http 请求端口的. 如何处理浏览器发送过来的 socket 请求的.这些实在是太有意思了.

最后我们以一个最常见的请求为基础, 写了 `<<深入理解 Tomcat（九）源码剖析之请求过程>>`, 理解了一个 HTTP 请求是如何从 socket 到达我们编写的 Servlet 的, 并且了解了tomcat 是如何设计各个容器直接的通信----使用管道和阀门. 也知道了 tomcat 是如何解析消息头, 如何设计过滤器. 让我们对 tomcat 的认识可以说更加的清晰.我们无意中也发现了 tomcat 7 中关于单例模式的一个潜在 bug(最新的 tomcat 已经修复).

最后, 就到了我们这篇总结的文章, 总的来说, 我们完成了我们最初定制的任务, 剖析了最重要的几个组件, 包括类加载器, 容器, 生命周期管理, 连接器, 管道, 阀门, 从启动过程和请求过程这两条路线去分析源码, 让我们不会在浩瀚的源码世界迷路. 虽然还要一些源码没有阅读, 但我们相信, 我们已经体会到了 tomcat 最重要的东西, 我们也不可能将所有的源码全都阅读一遍, 楼主是万万做不到的.

想想楼主最初阅读源码的目的, 就是好奇 tomcat 到底是如何实现的. 现在, 楼主认为楼主的疑问已经被解答, 接下来, 楼主就要研究另一个 Java 世界中有名的框架了, 楼主不要做个只知道 know how 不知道 know why 的人. 

加油!!! good luck !!!!



    








